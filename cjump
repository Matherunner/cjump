#!/usr/bin/env python

from __future__ import print_function
from argparse import ArgumentParser
import csv
import errno
import glob
import itertools
import os
import signal
import sys

# For Python 3
if sys.version_info >= (3, 0):
    raw_input = input

def interrupt_handler(signal, frame):
    print('No jump was made.', file=sys.stderr)
    sys.exit(1)

signal.signal(signal.SIGINT, interrupt_handler)

DEFAULT_DATABASE_PATH = os.path.join(
    os.path.expanduser('~'), '.cjump', 'aliases')
SEARCH_DEPTH_DEFAULT = 4

class AliasNotFound(Exception):
    def __init__(self, name):
        self.message = 'Alias "{}" not defined.'.format(name)

    def __str__(self):
        return self.message


def makedirs_if(path):
    try:
        os.makedirs(path)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise e

def load_database(filename):
    aliases = {}

    try:
        with open(filename, 'r') as file:
            alias_reader = csv.reader(file, delimiter=':')
            for row in alias_reader:
                if not row:
                    continue

                name = row[0].strip()
                if name[0] == '#':
                    # Ignore comments
                    continue

                # Treat the rest of ':' as part of path name rather than field
                # separator.
                path = ':'.join(row[1:])
                aliases[name] = path
    except IOError as e:
        if e.errno != errno.ENOENT:
            raise e

    return aliases

def save_database(filename, aliases):
    dirname = os.path.dirname(os.path.abspath(filename))
    makedirs_if(dirname)

    with open(filename, 'w') as file:
        print('''\
# DO NOT EDIT THIS FILE, ANY CHANGES WILL BE LOST
# This is automatically generated by cjump.
#
''', file=file)
        alias_writer = csv.writer(file, delimiter=':')
        for name, path in aliases.items():
            alias_writer.writerow([name.strip(), path])

def search_subdirs(depth, root, subdirs):
    if not subdirs:
        return [root]

    entries = []
    for i in range(depth):
        globs = []
        for dot_or_not in itertools.product(['*/', '.*/'], repeat=i):
            pattern = os.path.join(root, ''.join(dot_or_not), subdirs[0])
            globs.append(glob.iglob(pattern))
        for match in itertools.chain.from_iterable(globs):
            if os.path.isdir(match):
                entries += search_subdirs(depth, match, subdirs[1:])
    return entries

def subcommand_jump(args):
    aliases = load_database(args.database)
    if args.name == '.':
        # Special case: . refers to the working directory
        root = os.getcwd()
    elif args.name not in aliases:
        raise AliasNotFound(args.name)
    else:
        root = aliases[args.name]

    search_depth = SEARCH_DEPTH_DEFAULT
    try:
        # search_depth = int(os.environ.get('CJUMP_DEPTH', '4'))
        if 'CJUMP_DEPTH' in os.environ:
            search_depth = int(os.environ['CJUMP_DEPTH'])
        if search_depth <= 0:
            raise ValueError()
    except ValueError:
        print('Warning: Invalid CJUMP_DEPTH value! Defaulting to {}'.format(SEARCH_DEPTH_DEFAULT),
              file=sys.stderr)
        search_depth = SEARCH_DEPTH_DEFAULT

    # Make sure the aliased path still exists.
    if not os.path.exists(root):
        print('The directory defined by "{}" does not exist: {}'.format(args.name, root), file=sys.stderr)
        sys.exit(1)

    if args.subdirs:
        print('Searching subdirectories (may take a while)', file=sys.stderr)
    entries = search_subdirs(search_depth, root, args.subdirs)
    if not entries:
        print('No matches found. No jump was made.', file=sys.stderr)
        sys.exit(1)

    if len(entries) == 1:
        print(entries[0])
        return

    print('Multiple matches found:\n', file=sys.stderr)
    for i, entry in enumerate(entries, start=1):
        print('   ({}) {}'.format(i, entry), file=sys.stderr)
    print('', file=sys.stderr)

    # Repeatedly ask the user until we receive a valid index.
    while True:
        print('Which path to jump to? ', end='', file=sys.stderr)
        try:
            index = int(raw_input())
            chosen = entries[index - 1]
            if index <= 0:
                # 1-based index!
                raise IndexError()
            break
        except (ValueError, IndexError):
            print('Please input a correct index.', file=sys.stderr)
        except EOFError:
            print('No jump was made.', file=sys.stderr)
            sys.exit(1)

    print(chosen)

def subcommand_alias(args):
    aliases = load_database(args.database)
    if args.name is None:
        alias_width = max(len(name) for name in aliases.keys())
        for name, path in sorted(aliases.items()):
            print('{:>{width}} => "{}"'.format(name, path, width=alias_width))
    elif args.path is None:
        if args.name not in aliases:
            raise AliasNotFound(args.name)
        else:
            print('{} => "{}"'.format(args.name, aliases[args.name]))
    else:
        aliases[args.name] = os.path.abspath(args.path)
        save_database(args.database, aliases)

def subcommand_unalias(args):
    aliases = load_database(args.database)
    if args.name not in aliases:
        raise AliasNotFound(args.name)
    del aliases[args.name]
    save_database(args.database, aliases)

def main():
    parser = ArgumentParser()
    parser.add_argument('-d', '--database', default=DEFAULT_DATABASE_PATH, help='database file')

    subparsers = parser.add_subparsers(title='subcommands', help='actions')

    parser_jump = subparsers.add_parser('jump', help='jump help')
    parser_jump.add_argument('name', help='alias name')
    parser_jump.add_argument('subdirs', nargs='*', help='subdirectories to search for')
    parser_jump.set_defaults(func=subcommand_jump)

    parser_alias = subparsers.add_parser('alias', help='alias help')
    parser_alias.add_argument('name', nargs='?', help='name of alias')
    parser_alias.add_argument('path', nargs='?', help='path to point to')
    parser_alias.set_defaults(func=subcommand_alias)

    parser_unalias = subparsers.add_parser('unalias', help='unalias help')
    parser_unalias.add_argument('name', help='name of alias')
    parser_unalias.set_defaults(func=subcommand_unalias)

    args = parser.parse_args()
    if 'func' not in args:
        # This check is needed for Python 3
        parser.print_help()
        sys.exit(1)

    try:
        args.func(args)
    except AliasNotFound as e:
        print(e, file=sys.stderr)

if __name__ == '__main__':
    main()
