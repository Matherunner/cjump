#!/usr/bin/env python

from __future__ import print_function
from argparse import ArgumentParser
import csv
import errno
import glob
import itertools
import os
import sys

DEFAULT_DATABASE_PATH = os.path.join(
    os.path.expanduser('~'), '.cjump', 'aliases')

class AliasNotFound(Exception):
    def __init__(self, name):
        self.message = 'Alias "{}" not defined.'.format(name)

    def __str__(self):
        return self.message


def makedirs_if(path):
    try:
        os.makedirs(path)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise e

def load_database(filename):
    aliases = {}

    try:
        with open(filename, 'r') as file:
            alias_reader = csv.reader(file, delimiter=':')
            for row in alias_reader:
                if not row:
                    continue

                name = row[0].strip()
                if name[0] == '#':
                    # Ignore comments
                    continue

                # Treat the rest of ':' as part of path name rather than field
                # separator.
                path = ':'.join(row[1:])
                aliases[name] = path
    except IOError as e:
        if e.errno != errno.ENOENT:
            raise e

    return aliases

def save_database(filename, aliases):
    dirname = os.path.dirname(os.path.abspath(filename))
    makedirs_if(dirname)

    with open(filename, 'w') as file:
        print('''\
# DO NOT EDIT THIS FILE, ANY CHANGES WILL BE LOST
# This is automatically generated by cjump.
#
''', file=file)

        alias_writer = csv.writer(file, delimiter=':')
        for name, path in aliases.items():
            alias_writer.writerow([name.strip(), path])

def search_subdirs(depth, root, subdirs):
    if not subdirs:
        return [root]

    entries = []
    for i in range(depth):
        globs = []
        for dot_or_not in itertools.product(['*/', '.*/'], repeat=i):
            pattern = os.path.join(root, ''.join(dot_or_not), subdirs[0])
            globs.append(glob.iglob(pattern))
        for match in itertools.chain.from_iterable(globs):
            if os.path.isdir(match):
                entries += search_subdirs(depth, match, subdirs[1:])
    return entries

def subcommand_jump(args):
    aliases = load_database(args.database)
    if args.name == '.':
        # Special case: . refers to the working directory
        root = os.getcwd()
    elif args.name not in aliases:
        raise AliasNotFound(args.name)
    else:
        root = aliases[args.name]

    for entry in search_subdirs(args.depth, root, args.subdirs):
        print(entry)

def subcommand_alias(args):
    aliases = load_database(args.database)
    if args.name is None:
        for name, path in sorted(aliases.items()):
            print('{} => "{}"'.format(name, path))
    elif args.path is None:
        if args.name not in aliases:
            raise AliasNotFound(args.name)
        else:
            print('{} => "{}"'.format(args.name, aliases[args.name]))
    else:
        aliases[args.name] = os.path.abspath(args.path)
        save_database(args.database, aliases)

def subcommand_unalias(args):
    aliases = load_database(args.database)
    if args.name not in aliases:
        raise AliasNotFound(args.name)
    del aliases[args.name]
    save_database(args.database, aliases)

def main():
    parser = ArgumentParser()
    parser.add_argument('-d', '--database', default=DEFAULT_DATABASE_PATH, help='database file')

    subparsers = parser.add_subparsers(title='subcommands', help='actions')

    parser_jump = subparsers.add_parser('jump', help='jump help')
    parser_jump.add_argument('-d', '--depth', type=int, default=4, help='maximimum depth to search for each subdir')
    parser_jump.add_argument('name', help='alias name')
    parser_jump.add_argument('subdirs', nargs='*', help='subdirectories to search for')
    parser_jump.set_defaults(func=subcommand_jump)

    parser_alias = subparsers.add_parser('alias', help='alias help')
    parser_alias.add_argument('name', nargs='?', help='name of alias')
    parser_alias.add_argument('path', nargs='?', help='path to point to')
    parser_alias.set_defaults(func=subcommand_alias)

    parser_unalias = subparsers.add_parser('unalias', help='unalias help')
    parser_unalias.add_argument('name', help='name of alias')
    parser_unalias.set_defaults(func=subcommand_unalias)

    args = parser.parse_args()
    try:
        args.func(args)
    except AliasNotFound as e:
        print(e, file=sys.stderr)

if __name__ == '__main__':
    main()
